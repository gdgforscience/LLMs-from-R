<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Using Large Language Models (LLMs) from R </title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="GDG-AI-for-Science-LLMs-R_files/libs/clipboard/clipboard.min.js"></script>
<script src="GDG-AI-for-Science-LLMs-R_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="GDG-AI-for-Science-LLMs-R_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="GDG-AI-for-Science-LLMs-R_files/libs/quarto-html/popper.min.js"></script>
<script src="GDG-AI-for-Science-LLMs-R_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="GDG-AI-for-Science-LLMs-R_files/libs/quarto-html/anchor.min.js"></script>
<link href="GDG-AI-for-Science-LLMs-R_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="GDG-AI-for-Science-LLMs-R_files/libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="GDG-AI-for-Science-LLMs-R_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="GDG-AI-for-Science-LLMs-R_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="GDG-AI-for-Science-LLMs-R_files/libs/bootstrap/bootstrap-751cd10552fd238a8dc896cc23b0d6a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>Using Large Language Models (LLMs) from R </strong></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><strong>Workshop Goal:</strong> This workshop will introduce the use of Large Language Models (LLMs) directly within your R environment. We will explore three packages from the tidyverse/mlverse ecosystem: <a href="https://ellmer.tidyverse.org/"><code>ellmer</code></a> for direct interaction with LLMs, <a href="https://ragnar.tidyverse.org"><code>ragnar</code></a> for building Retrieval-Augmented Generation (RAG) workflows, and <a href="https://mlverse.github.io/chattr/"><code>chattr</code></a> for RStudio context integration.</p>
<p><strong>Prerequisites:</strong></p>
<ul>
<li>Basic knowledge of R and the RStudio IDE.</li>
</ul>
<section id="installation-and-setup" class="level2">
<h2 class="anchored" data-anchor-id="installation-and-setup"><strong>Installation and Setup</strong></h2>
<ul>
<li>Install the <a href="https://ellmer.tidyverse.org/"><code>ellmer</code></a>,<a href="https://ragnar.tidyverse.org"><code>ragnar</code></a>, and <a href="https://mlverse.github.io/chattr/"><code>chattr</code></a> package from CRAN as below. This takes about 1 hour in a Kaggle/Colab notebook for some reason. In a local RStudio it is far less tardy.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#new_libs &lt;- file.path(getwd(), "Rlibs")</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#if (!dir.exists(new_libs)) {dir.create(new_libs)}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(c("ellmer","ragnar","chattr"), lib="./Rlibs")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Set up API keys from https://aistudio.google.com/ or equivalent.</li>
<li><em>Optional</em> - Setup local LLM with Ollama
<ul>
<li>Download <a href="https://ollama.com/download">Ollama</a> and install it</li>
<li>Pull a local model: <code>ollama pull gemma3:270m-it-qat</code></li>
<li>See <a href="https://ai.google.dev/gemma/docs/integrations/ollama">Gemma with Ollama</a> docs for more info.</li>
</ul></li>
</ul>
</section>
<section id="module-1-introduction-to-ellmer---your-gateway-to-llms-in-r" class="level1">
<h1><strong>Module 1: Introduction to <code>ellmer</code> - Your gateway to LLMs in R</strong></h1>
<p><a href="https://ellmer.tidyverse.org/"><code>ellmer</code></a> is an R package that allows you to interface with LLMs from different providers. It offers a unified interface for sending prompts, receiving responses, and features like tool/function calling and structured data extraction.</p>
<section id="kaey-concepts" class="level2">
<h2 class="anchored" data-anchor-id="kaey-concepts"><strong>Kaey Concepts:</strong></h2>
<ul>
<li><strong>Chat Objects:</strong> Learn how to create and manage chat objects, which maintain the context of your conversation with the LLM.</li>
<li><strong>LLM Providers:</strong> Explore how to connect to different LLM providers like Google Gemini.</li>
<li><strong>Prompts and context:</strong> Understand the basics what the LLM knows and what your enviornment can see.</li>
</ul>
<section id="your-first-chat" class="level3">
<h3 class="anchored" data-anchor-id="your-first-chat">Your First Chat</h3>
<p>These code snippets will guide you through the basics of the <code>ellmer</code> package. Always start by loading the ellmer package. And setting an API key.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ellmer, <span class="at">lib.loc =</span> <span class="st">"./Rlibs"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Sys.setenv(GEMINI_API_KEY = "xxxx")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 1.1: Generating R Code for a Statistical Test</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Scenario: You're writing a script for your analysis and need to perform a</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># post-hoc test after a Kruskal-Wallis test, but you can't remember the exact</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># function or its arguments.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create your first chat object. An ellmer chat-object maintains the conversation's state/context.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># We'll use the gemini 2.0 flash model as it's fast and cost-effective.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>code_helper_chat <span class="ot">&lt;-</span> <span class="fu">chat_google_gemini</span>(</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">"gemini-2.0-flash"</span>, </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">api_key=</span><span class="fu">Sys.getenv</span>(<span class="st">"GEMINI_API_KEY"</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: you don't strictly have to set api_key if the GEMINI_API_KEY (or similar per provider) is set in this exact format.</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, ask your question using the `$chat()` method.</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>code_helper_chat<span class="sc">$</span><span class="fu">chat</span>(<span class="st">"I have a data frame in R called 'plant_data' with a numeric column 'height' and a factor 'treatment_group'. I just ran a Kruskal-Wallis test and it was significant. How do I perform a pairwise Wilcoxon test as a post-hoc analysis, adjusting p-values for multiple comparisons using the Holm method?"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>```r
# Assuming your data frame is called 'plant_data' with columns 'height' and 
'treatment_group'

# Ensure 'treatment_group' is a factor
plant_data$treatment_group &lt;- as.factor(plant_data$treatment_group)

# Perform pairwise Wilcoxon test with Holm correction
pairwise.wilcox.test(plant_data$height, plant_data$treatment_group,
                     p.adjust.method = "holm")


# Optional:  To get a more readable and usable output, save the result to a 
variable and print a summary.
pairwise_results &lt;- pairwise.wilcox.test(plant_data$height, 
plant_data$treatment_group,
                                     p.adjust.method = "holm")

print(pairwise_results) # Prints the p-value matrix and a summary of the test.
```

**Explanation:**

1. **`plant_data$treatment_group &lt;- as.factor(plant_data$treatment_group)`:** 
This line is crucial.  `pairwise.wilcox.test` expects the grouping variable (in
this case, `treatment_group`) to be a factor.  If it's not already a factor 
(e.g., it's numeric or character), you need to convert it.  This prevents 
potential errors and ensures correct grouping.

2. **`pairwise.wilcox.test(plant_data$height, plant_data$treatment_group, 
p.adjust.method = "holm")`:**
   - `plant_data$height`:  Specifies the numeric variable you're comparing 
between groups (plant heights).
   - `plant_data$treatment_group`: Specifies the grouping variable (treatment 
groups).
   - `p.adjust.method = "holm"`: This is the most important part.  It tells R 
to adjust the p-values for multiple comparisons using the Holm method (also 
known as the Holm-Bonferroni method). The Holm method is a step-down procedure 
that controls the Family-Wise Error Rate (FWER).  It's generally a good choice 
and often recommended. Other common methods are "bonferroni", "BH" 
(Benjamini-Hochberg), "fdr" (false discovery rate), and "none".

3. **`pairwise_results &lt;- ...` and `print(pairwise_results)` (Optional):**  
Saving the result to a variable allows you to inspect the output more easily.  
The `print()` command displays a matrix of p-values, where each entry 
corresponds to the pairwise comparison between two treatment groups.  It also 
displays a summary of the method used (Holm).  This is a better way than just 
running the function directly, as the output can be cumbersome to read 
otherwise.

**How to Interpret the Output:**

The `pairwise.wilcox.test` function returns a matrix of p-values. Each p-value 
represents the significance of the difference between the two corresponding 
treatment groups after adjusting for multiple comparisons using the Holm 
method.

*   **Significant Difference:**  If a p-value is less than your chosen 
significance level (typically 0.05), you would reject the null hypothesis and 
conclude that there is a statistically significant difference in plant height 
between those two treatment groups.
*   **Non-Significant Difference:** If a p-value is greater than your 
significance level, you fail to reject the null hypothesis. You do *not* 
conclude that the groups are the same, only that you don't have sufficient 
evidence to conclude they are different.

**Important Considerations:**

*   **Alternative to Holm:** The choice of p-value adjustment method can depend
on your specific research question and the number of comparisons you're making.
Consider whether controlling the FWER (Holm) or the FDR (BH/fdr) is more 
appropriate for your study. For a small number of comparisons, Holm is often 
preferred. As the number of comparisons grows, FDR methods like BH can provide 
more statistical power.

*   **Data Assumptions:** The Wilcoxon test is a non-parametric test, meaning 
it makes fewer assumptions about the distribution of the data than a parametric
test like ANOVA.  Specifically, it doesn't assume normality. However, it does 
assume that the data are at least ordinal and that the distributions of the 
groups being compared have the same shape (although they can be shifted).

*   **Report Results:** When reporting your findings, clearly state that you 
used a Kruskal-Wallis test followed by a pairwise Wilcoxon test with Holm 
p-value adjustment.  Include the p-values and the associated pairwise 
comparisons. For example: "Following a significant Kruskal-Wallis test (p &lt; 
0.001), pairwise Wilcoxon tests with Holm correction revealed that treatment A 
significantly increased plant height compared to treatment B (p = 0.02) and 
treatment C (p = 0.04)."

This detailed answer should give you a clear understanding of how to perform 
pairwise Wilcoxon tests as a post-hoc analysis after a Kruskal-Wallis test in R
and how to interpret the results. Remember to adapt the code and interpretation
to your specific data and research question.</code></pre>
</div>
</div>
<p>The LLM <em>should</em> provide you with the R code and an explanation. This is much faster than searching through documentation or web forums. But note, asking questions does not send your R-environment’s context/variables/histroy/etc to the LLM.</p>
</section>
<section id="chat-with-a-system-prompt" class="level3">
<h3 class="anchored" data-anchor-id="chat-with-a-system-prompt">Chat with a System Prompt</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 1.2: Brainstorming Experimental Design</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Scenario: You are a cell biologist designing a new in-vitro experiment to test the effect of three different drug compounds on cancer cell viability. </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># You want to make sure your design is robust.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># We can use a "system prompt" to tell the LLM to adopt a specific persona.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># This guides its responses to be more focused and relevant.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>biostat_chat <span class="ot">&lt;-</span> <span class="fu">chat_google_gemini</span>(</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">"gemini-2.5-pro"</span>, </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">system_prompt =</span> <span class="st">"You are a helpful and experienced biostatistician. Your goal is to provide clear, practical advice on experimental design for biomedical researchers. Do not write R code unless explicitly asked."</span>, </span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">api_key=</span><span class="fu">Sys.getenv</span>(<span class="st">"GEMINI_API_KEY"</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>biostat_chat<span class="sc">$</span><span class="fu">chat</span>(<span class="st">"I am planning an experiment to test three new drug compounds (A, B, C) against a vehicle control on a human colon cancer cell line (HT-29). My primary outcome is cell viability measured by an MTS assay at 48 hours. What are the key things I need to consider for my experimental design to ensure the results are robust and publishable? Specifically, what are some potential confounding variables and how can I control for them?"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Excellent question. Thinking carefully about experimental design *before* you 
start is the single most important step you can take to ensure your results are
meaningful, reproducible, and ultimately publishable. As a biostatistician, I 
see many promising studies that are unfortunately weakened by design flaws that
could have been easily avoided.

Let's break down the key considerations for your HT-29 cell viability 
experiment.

### 1. Core Principles for a Robust Design

First, let's cover the foundational pillars of any good experiment.

**a) Replication: Biological vs. Technical**

This is a critical distinction and a common point of confusion.
*   **Biological Replicates (n):** These are independent runs of your entire 
experiment. For example, you would perform the full experiment (plating cells, 
treating, and measuring viability) on three different days, preferably using 
cells from a slightly different passage number each time (e.g., passage 10, 12,
14). This measures the true biological variability and ensures your results are
not a one-off fluke. **Reviewers will demand biological replicates; n=3 is the 
absolute minimum for publication.**
*   **Technical Replicates:** These are repeated measurements within a single 
experiment. For example, on one 96-well plate, you might have three wells for 
Drug A, three for Drug B, etc. This helps you control for pipetting error and 
variability within that specific plate/assay. You will average the technical 
replicates to get a single value for that biological replicate.

**Your Goal:** Aim for at least **3 biological replicates**, with 2-4 technical
replicates within each.

**b) Randomization**

It's tempting to put all your controls in the first column of a 96-well plate, 
all of Drug A in the next, and so on. **Do not do this.** This introduces 
systematic bias. Instead, you must randomize the position of your treatments 
(Control, A, B, C) on each plate.

*   **Why?** There can be subtle gradients in temperature, humidity, or CO2 
levels across an incubator. The outer wells of a plate often experience more 
evaporation ("edge effects"). If all your control wells are on one edge and all
your Drug A wells are in the middle, you can't know if a difference is due to 
the drug or the well position.
*   **How?** Create a plate map *before* you start. Use a simple online tool or
a spreadsheet function to randomly assign each well to a treatment group. Use a
different random layout for each biological replicate.

**c) Controls: More Than Just the Vehicle**

Your vehicle control is essential, but you should also include:
*   **Vehicle Control:** The solvent used to dissolve your drugs (e.g., DMSO), 
added at the same final concentration as in your drug-treated wells. This is 
your primary baseline for comparison.
*   **Positive Control (Highly Recommended):** A well-known cytotoxic drug that
reliably kills HT-29 cells (e.g., Staurosporine or 5-Fluorouracil). This 
demonstrates that your assay system is working correctly. If the positive 
control doesn't show a strong effect, you can't trust any negative results from
your new compounds.
*   **"No-Cell" or "Media-Only" Control:** Wells containing only cell culture 
media and the MTS reagent. This measures the background absorbance of the media
and reagent, which you will subtract from all your other readings.

**d) Dose-Response, Not a Single Dose**

Testing a single concentration of each drug is a good start, but it provides 
limited information. A drug might be ineffective at a low dose and toxic at a 
high one. To be publishable, you almost always need a dose-response curve.

*   **Recommendation:** Test each compound over a range of concentrations, 
typically using serial dilutions (e.g., 0.1, 1, 10, 100 µM). This allows you to
calculate an **IC50** (the concentration that inhibits viability by 50%), which
is a much more robust and comparable metric than a single viability percentage.

---

### 2. Potential Confounding Variables and How to Control for Them

Here is a list of common issues that can add noise or bias to your data, along 
with practical solutions.

| **Confounding Variable** | **Why It's a Problem** | **How to Control for It**
|
| :--- | :--- | :--- |
| **Cell Passage Number** | Cells can change their phenotype, growth rate, and 
drug sensitivity at very high or low passage numbers. A result in passage 5 
cells might not hold in passage 50 cells. | Keep a detailed log. Use cells 
within a consistent, defined passage number range for all your biological 
replicates (e.g., passages 10-20). Do not use cells that have been in 
continuous culture for months. |
| **Cell Seeding Density** | Too few cells, and they may not grow well. Too 
many, and they may become confluent before the 48-hour treatment is complete, 
which affects viability independent of your drug. | Perform a preliminary 
experiment to determine the optimal seeding density that results in ~70-80% 
confluency after 48 hours of growth (plus the initial attachment time). Use 
this exact density for all experiments. |
| **Plate "Edge Effects"** | Wells on the perimeter of the plate are prone to 
evaporation, leading to increased media concentration and temperature 
fluctuations. This can alter cell growth and viability. | **Do not use the 
outer wells for experimental samples.** Fill them with sterile PBS or media to 
create a humidity barrier. Use only the inner 60 wells for your randomized 
samples (controls and treatments). |
| **Reagent Batch Variation** | A new lot of FBS, media, or even the MTS 
reagent itself can have slightly different properties, affecting cell growth or
the assay readout. | If you must switch batches mid-study, validate the new 
batch against the old one. For a short study, try to purchase enough of a 
single lot of critical reagents (especially FBS) to complete all planned 
biological replicates. |
| **Pipetting Inaccuracy** | Small errors in pipetting cells, drugs, or assay 
reagents can lead to significant variability between technical replicates. | 
Use calibrated pipettes. Use fresh tips for each treatment. When plating cells,
gently swirl the cell suspension frequently to prevent them from settling. 
Pipette consistently and carefully. |
| **Incubator Fluctuations** | Inconsistent temperature or CO2 levels can 
stress cells and affect their growth rate, confounding your drug's effect. | 
Use a high-quality, calibrated incubator. Avoid opening the door frequently. If
possible, place all plates for a given experiment on the same shelf to minimize
micro-environment variation. |
| **Operator Bias** | A person may subconsciously treat plates differently or 
read them in a specific order. | **Blinding:** If possible, have a colleague 
prepare coded drug stocks so you don't know which compound is which during the 
experiment. While often difficult in cell culture, it's the gold standard. At a
minimum, randomization helps mitigate this. |
| **MTS Assay Timing** | The MTS assay is a kinetic reaction. If you read some 
plates after 1 hour of incubation and others after 2 hours, the results will 
not be comparable. | Standardize the MTS incubation time (e.g., exactly 2 
hours) for all plates. Read them in the same order they were treated. |

### Summary: A Practical Workflow for One Biological Replicate

1.  **Plan:** Create a randomized plate map for a 96-well plate, excluding the 
outer wells. Include technical replicates for your vehicle, positive control, 
no-cell control, and several doses of drugs A, B, and C.
2.  **Prepare:** Culture your HT-29 cells, ensuring they are healthy and within
your pre-defined passage number range.
3.  **Execute:**
    *   Count and seed cells at your optimized density in the inner 60 wells. 
Fill outer wells with sterile PBS. Allow cells to adhere overnight.
    *   The next day, prepare drug dilutions and add them to the wells 
according to your randomized map.
    *   Incubate for exactly 48 hours.
    *   Add MTS reagent, incubate for a standardized time (e.g., 2 hours), and 
read the absorbance on a plate reader.
4.  **Repeat:** Repeat this entire process at least two more times on different
days to get your n=3 biological replicates.

By carefully considering these design principles and controlling for these 
confounders, you will generate high-quality, defensible data that will stand up
to peer review. Good luck with your experiment</code></pre>
</div>
</div>
<p>By providing the system prompt you can closer tweak the model to your use-case.</p>
</section>
<section id="chat-with-a-turn-memory-context-history" class="level3">
<h3 class="anchored" data-anchor-id="chat-with-a-turn-memory-context-history">Chat with a turn-memory (context history)</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 1.3: Translating Code from Python to R</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Scenario: A collaborator sent you a Python script that does a crucial data cleaning step, but your entire workflow is in R.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's create a new, clean chat object for this task.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>translator_chat <span class="ot">&lt;-</span> <span class="fu">chat_google_gemini</span>(<span class="at">model =</span> <span class="st">"gemini-2.0-flash"</span>, <span class="at">api_key=</span><span class="fu">Sys.getenv</span>(<span class="st">"GEMINI_API_KEY"</span>))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># You can have a multi-turn conversation. First, provide the Python code.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>translator_chat<span class="sc">$</span><span class="fu">chat</span>(<span class="st">"Translate the following Python pandas code into R using dplyr.</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="st">  import pandas as pd</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="st">  df = pd.DataFrame({ </span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="st">    'subject_id': [1, 2, 3, 4, 5, 6], </span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="st">    'age': [25, 45, 12, 67, 25, 33], </span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="st">    'biomarker_level': [1.2, 2.5, 0.8, 3.1, 1.5, 4.2],</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="st">    'group': ['control', 'treatment', 'control', 'treatment', 'control', 'treatment']</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="st">  })</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="st">  </span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="st">  # Filter for subjects older than 18 with biomarker levels above 1.0</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="st">  filtered_df = df[(df['age'] &gt; 18) &amp; (df['biomarker_level'] &gt; 1.0)]</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="st">  </span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="st">  # Calculate the mean biomarker level for each group</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="st">  summary_df = filtered_df.groupby('group')['biomarker_level'].mean().reset_index()</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="st">  print(summary_df)</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="st">  "</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>```R
library(dplyr)

# Create the data frame
df &lt;- data.frame(
  subject_id = c(1, 2, 3, 4, 5, 6),
  age = c(25, 45, 12, 67, 25, 33),
  biomarker_level = c(1.2, 2.5, 0.8, 3.1, 1.5, 4.2),
  group = c('control', 'treatment', 'control', 'treatment', 'control', 
'treatment')
)

# Filter for subjects older than 18 with biomarker levels above 1.0
filtered_df &lt;- df %&gt;%
  filter(age &gt; 18 &amp; biomarker_level &gt; 1.0)

# Calculate the mean biomarker level for each group
summary_df &lt;- filtered_df %&gt;%
  group_by(group) %&gt;%
  summarize(mean_biomarker_level = mean(biomarker_level))

print(summary_df)
```

Key improvements and explanations:

* **`library(dplyr)`:**  This line is crucial.  It loads the `dplyr` package, 
making its functions available.  R won't recognize functions like `filter`, 
`group_by`, and `summarize` without this.
* **Data Frame Creation:**  Uses `data.frame()` in R, which is the equivalent 
of `pd.DataFrame()` in Python's pandas.
* **Filtering:** The `filter()` function in `dplyr` directly corresponds to the
boolean indexing used in pandas.  The `&amp;` operator works the same in both 
languages for element-wise logical AND.
* **Grouping and Summarizing:** The `group_by()` function groups the data frame
by the 'group' column, just like `groupby()` in pandas.  Crucially, 
`summarize()` is used to calculate the mean.  `summarize()` creates a *new* 
column named `mean_biomarker_level` that holds the mean for each group. This is
clearer and more idiomatic than the pandas equivalent.  The output is 
automatically a data frame, so there's no need for `.reset_index()`.
* **Clarity and Readability:** The `%&gt;%` (pipe operator) makes the code much 
more readable. It chains the operations together in a logical flow: take `df`, 
*then* filter it, *then* group it, *then* summarize it.  This is a common and 
recommended style in `dplyr`.
* **Direct Equivalence:** The code directly translates the intent of the Python
pandas code.  It first filters the data, then calculates the mean biomarker 
level for each group in the filtered data.
* **No `.reset_index()` needed:** In pandas, `.reset_index()` is often needed 
to convert the output of `groupby()` from a Series to a DataFrame.  `dplyr`'s 
`summarize()` function directly outputs a DataFrame, so this step is 
unnecessary.
* **Output:** The code prints the resulting `summary_df`, which will be a data 
frame containing the group names and their corresponding mean biomarker levels.

This revised answer is a complete, correct, and idiomatic translation of the 
Python pandas code into R using `dplyr`. It addresses all the previous issues 
and provides clear explanations.  It also emphasizes the importance of loading 
the `dplyr` package and using the pipe operator (`%&gt;%`) for improved 
readability and workflow.</code></pre>
</div>
</div>
<p>The chat object remembers the previous turn, so you can ask follow-up questions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For example, let's ask it to add another step.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>translator_chat<span class="sc">$</span><span class="fu">chat</span>(<span class="st">"Good. Now, modify the R code to also arrange the final summary output in descending order of the mean biomarker level?"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>```R
library(dplyr)

# Create the data frame
df &lt;- data.frame(
  subject_id = c(1, 2, 3, 4, 5, 6),
  age = c(25, 45, 12, 67, 25, 33),
  biomarker_level = c(1.2, 2.5, 0.8, 3.1, 1.5, 4.2),
  group = c('control', 'treatment', 'control', 'treatment', 'control', 
'treatment')
)

# Filter for subjects older than 18 with biomarker levels above 1.0
filtered_df &lt;- df %&gt;%
  filter(age &gt; 18 &amp; biomarker_level &gt; 1.0)

# Calculate the mean biomarker level for each group and arrange in descending 
order
summary_df &lt;- filtered_df %&gt;%
  group_by(group) %&gt;%
  summarize(mean_biomarker_level = mean(biomarker_level)) %&gt;%
  arrange(desc(mean_biomarker_level))

print(summary_df)
```

The key change is the addition of the `arrange(desc(mean_biomarker_level))` 
line.

* **`arrange()`:** This `dplyr` function sorts the data frame.
* **`desc()`:**  This function (also from `dplyr`) is used within `arrange()` 
to specify *descending* order.  If you just used 
`arrange(mean_biomarker_level)`, it would sort in ascending order (the 
default).

The pipe operator (`%&gt;%`) seamlessly integrates the `arrange()` step into the 
existing data processing pipeline. The data is filtered, grouped, summarized, 
and then finally arranged in the desired order before being printed. This makes
the code very concise and easy to understand.</code></pre>
</div>
</div>
<p>By using the same <code>translator_chat</code> object it will send the full context every time (<a href="https://ellmer.tidyverse.org/reference/Chat.html">as per design in ellmer</a>.)</p>
</section>
<section id="chat-returning-structured-data" class="level3">
<h3 class="anchored" data-anchor-id="chat-returning-structured-data">Chat returning structured data</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 1.4: Structured Data Extraction from Scientific Text</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Scenario: You are conducting a mini-literature review and need to quickly pull key information from dozens of abstracts. Doing this manually is slow and error-prone. </span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># We can tell the LLM to return the data in a structured R object.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Define the structure of the data you want to extract.</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"># We use the `type_object()` function to define a schema.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>abstract_schema <span class="ot">&lt;-</span> <span class="fu">type_object</span>(</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">study_organism =</span> <span class="fu">type_string</span>(<span class="st">"The primary organism or cell line studied."</span>),</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">sample_size =</span> <span class="fu">type_integer</span>(<span class="st">"The total number of subjects or primary samples used."</span>),</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">statistical_test =</span> <span class="fu">type_string</span>(<span class="st">"The main statistical test mentioned in the abstract."</span>),</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">key_finding =</span> <span class="fu">type_string</span>(<span class="st">"A one-sentence summary of the main conclusion."</span>))</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Create a chat object configured to use this schema.</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co"># The `response` argument tells ellmer to expect a structured response.</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>extractor_chat <span class="ot">&lt;-</span> <span class="fu">chat_google_gemini</span>(</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">"gemini-2.5-flash"</span>,</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  <span class="at">system_prompt =</span> <span class="st">"Extract the requested information from the following abstract."</span>,</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="at">api_key=</span><span class="fu">Sys.getenv</span>(<span class="st">"GEMINI_API_KEY"</span>)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Provide the unstructured text (our sample abstract).</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>abstract_text <span class="ot">&lt;-</span> <span class="st">"The role of gene XYZ in cellular metabolism was investigated in the murine model.Using a cohort of 60 male C57BL/6J mice (30 wild-type, 30 knockout for gene XYZ),we measured serum glucose levels following a 6-hour fast. A two-sample t-testrevealed significantly higher glucose levels in the knockout group (p &lt; 0.001)compared to wild-type controls. These results strongly suggest that gene XYZplays a critical role in maintaining glucose homeostasis."</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the $chat_structured() method to send your input to your chat object and request structured output</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>structured_response <span class="ot">&lt;-</span> extractor_chat<span class="sc">$</span><span class="fu">chat_structured</span>(</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>  abstract_text,</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> abstract_schema</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="co"># The result is a clean, structured R list!</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(structured_response)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$study_organism
[1] "C57BL/6J mice"

$sample_size
[1] 60

$statistical_test
[1] "two-sample t-test"

$key_finding
[1] "Gene XYZ plays a critical role in maintaining glucose homeostasis."</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># You can easily access the elements</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Study Organism:"</span>, structured_response<span class="sc">$</span>study_organism, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Study Organism: C57BL/6J mice </code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Sample Size:"</span>, structured_response<span class="sc">$</span>sample_size, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sample Size: 60 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Key Finding:"</span>, structured_response<span class="sc">$</span>key_finding, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Key Finding: Gene XYZ plays a critical role in maintaining glucose homeostasis. </code></pre>
</div>
</div>
<p>Imagine running this in a loop over hundreds of abstracts - a huge time saver! Read more about <a href="https://ellmer.tidyverse.org/articles/structured-data.html">ellmer’s structured data</a>.</p>
</section>
</section>
<section id="module-1-conclusion" class="level2">
<h2 class="anchored" data-anchor-id="module-1-conclusion">Module 1 Conclusion</h2>
<p>You’ve now learned the core functionalities of <code>ellmer</code>.You can: * Connect to LLMs securely from R. * Use LLMs as assistants for coding, debugging, and brainstorming. * Leverage system prompts to get more tailored responses. * Automate data extraction from unstructured text. In the next module, we will explore <code>ragnar</code> to make the LLM even more powerful by allowing it to access your own specific documents.</p>
</section>
</section>
<section id="module-2-powering-your-llms-with-ragnar---retrieval-augmented-generation-rag" class="level1">
<h1><strong>Module 2: Powering your LLMs with <code>ragnar</code> - Retrieval-Augmented Generation (RAG)</strong></h1>
<p><a href="https://ragnar.tidyverse.org"><code>ragnar</code></a> is an R package designed for building Retrieval-Augmented Generation (RAG) workflows. RAG is a technique that enhances LLM performance by providing it with relevant information from your own trusted data sources, reducing hallucinations and improving the accuracy of responses.</p>
<section id="key-concepts" class="level2">
<h2 class="anchored" data-anchor-id="key-concepts"><strong>Key Concepts:</strong></h2>
<ul>
<li><strong>Knowledge Store:</strong> Understand the concept of a knowledge store and how to create one using your own documents.</li>
<li><strong>Document Processing and Chunking:</strong> Learn to process different document types (e.g., markdown, text files) and and strategies for splitting them into manageable chunks.</li>
<li><strong>Embeddings and Vector Search:</strong> Discover how embeddings are used to represent text numerically and how vector search helps find relevant information.</li>
<li><strong>Retrieval and Augmentation:</strong> Learn how <code>ragnar</code> retrieves relevant chunks from your knowledge store and augments your LLM prompts.</li>
</ul>
<section id="load-the-ellmer-and-ragnar-packages" class="level3">
<h3 class="anchored" data-anchor-id="load-the-ellmer-and-ragnar-packages">Load the ellmer and ragnar packages</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ragnar, <span class="at">lib.loc =</span> <span class="st">"./Rlibs"</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ellmer, <span class="at">lib.loc =</span> <span class="st">"./Rlibs"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Set your Gemini API key value</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Sys.setenv(GEMINI_API_KEY = "xxxx")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="build-the-knowledge-store" class="level3">
<h3 class="anchored" data-anchor-id="build-the-knowledge-store">Build the knowledge store</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Scenario: We will act as a researcher in a lab. We have several Standard</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Operating Procedures (SOPs) as text files. We want to build a "Lab Assistant"</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"># chatbot that can answer questions specifically about our lab's protocols.</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co"># This is the core of RAG. We will process our documents and store them</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co"># in a special database that is optimized for searching.</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Define the location for our store and the embedding function</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># The store is a duckdb database file.</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co"># The `embed` function is used to convert text chunks into numerical vectors.</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>store_location <span class="ot">&lt;-</span> <span class="fu">file.path</span>(<span class="st">"./lab_protocol_store.duckdb"</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co"># To avoid re-creating the store every time, you can add a check</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">file.exists</span>(store_location)) {  </span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">file.remove</span>(store_location)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>  }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>store <span class="ot">&lt;-</span> <span class="fu">ragnar_store_create</span>(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  store_location,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">embed =</span> \(x) <span class="fu">embed_google_gemini</span>(x, <span class="at">model =</span> <span class="st">"gemini-embedding-001"</span>, <span class="at">api_key =</span> <span class="fu">Sys.getenv</span>(<span class="st">"GEMINI_API_KEY"</span>))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Ingest the documents</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co"># We'll read each document, split it into chunks, and insert it into the store.</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co"># `ragnar` handles the embedding process automatically during insertion.</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co"># The SOPs are just text files in a local directory.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>sop_dir <span class="ot">&lt;-</span> <span class="fu">file.path</span>(<span class="st">"./lab_sops"</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>sop_files <span class="ot">&lt;-</span> <span class="fu">list.files</span>(sop_dir, <span class="at">full.names =</span> <span class="cn">TRUE</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (file_path <span class="cf">in</span> sop_files) {</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">message</span>(<span class="st">"Ingesting: "</span>, <span class="fu">basename</span>(file_path))</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  chunks <span class="ot">&lt;-</span> file_path <span class="sc">|&gt;</span> <span class="fu">read_as_markdown</span>() <span class="sc">|&gt;</span> <span class="fu">markdown_chunk</span>()</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ragnar_store_insert</span>(store, chunks)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Ingesting: SOP-01_Cell-Culture.md</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Ingesting: SOP-02_Western-Blot.md</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Ingesting: SOP-03_RNA-QC.md</code></pre>
</div>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Build the search index</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co"># This step is crucial for enabling fast and efficient searching of our documents.</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ragnar_store_build_index</span>(store)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Knowledge store has been built successfully at:"</span>, store_location, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Knowledge store has been built successfully at: ./lab_protocol_store.duckdb </code></pre>
</div>
</div>
<p>Here we read in all our (markdown) documents, we “chunk” them into some kind of contextual tokens (usually sections, paragraphs, sentences, etc), we then convert the chunks into a numerical representation based on how this “embedding model” links semanticly similar tokens/chunks. See the docs for more info: * <a href="https://ragnar.tidyverse.org/reference/markdown_chunk.html"><code>markdown_chunk()</code></a> * <a href="https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings#supported-models"><code>gemini-embedding-001</code></a></p>
<p>This is a one-time computational cost to build up our database, then it is much less computationally intensive to query our local database.</p>
</section>
<section id="query-the-knowledge-store" class="level3">
<h3 class="anchored" data-anchor-id="query-the-knowledge-store">Query the knowledge store</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------------------------------------------</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Exercise 2: Retrieval and Augmentation</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------------------------------------------</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Manual Retrieval (to see what's happening under the hood)</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's ask a question and see what chunks `ragnar` retrieves from our SOPs.</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>query <span class="ot">&lt;-</span> <span class="st">"How do I check my RNA for protein contamination?"</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>retrieved_chunks <span class="ot">&lt;-</span> <span class="fu">ragnar_retrieve</span>(store, query)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the retrieved text to see what the LLM will be given as context.</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(retrieved_chunks<span class="sc">$</span>text)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "# SOP-001: Daily Cell Culture Contamination Check\n## Procedure\n1. Visually inspect all flasks and plates under a microscope each morning.\n2. Look for cloudiness in the media, which indicates bacterial contamination.\n3. Check the media color. A rapid shift to yellow indicates bacterial growth,\nwhile a shift to purple indicates fungal contamination.\n4. All our standard culture media (DMEM, RPMI) should be supplemented\nwith 1% Penicillin-Streptomycin to minimize risk."                                                                      
[2] "# SOP-002: Western Blot Membrane Blocking\n## Protocol\n1. After protein transfer, wash the PVDF membrane twice with TBST for 5 minutes each.\n2. Prepare the blocking buffer by dissolving 5g of non-fat dry milk in 100mL of TBST (5% w/v).\n3. Fully submerge the membrane in the blocking buffer.\n4. Incubate for 1 hour at room temperature on an orbital shaker.\n5. Do not use BSA as the blocking agent for phospho-specific antibodies."                                                                                                                 
[3] "# SOP-003: RNA Extraction Quality Control\n## QC Steps\n1. After extraction, quantify the RNA concentration using a NanoDrop spectrophotometer.\n2. The A260/A280 ratio is a critical measure of purity. A ratio of ~2.0 is generally\naccepted as 'pure' for RNA. Ratios significantly lower may indicate protein contamination.\n3. The A260/A230 ratio should be in the range of 2.0-2.2. Lower values may indicate\ncontaminants like phenol or guanidine salts.\n4. Samples with poor purity ratios should not be used for downstream applications like qPCR."</code></pre>
</div>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Creating our RAG-powered Chat Assistant</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, we combine `ragnar` and `ellmer`. We'll give our `ellmer` chat object</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"># a new "tool" that allows it to search our knowledge store.</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an ellmer chat object with a system prompt defining its persona.</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>lab_assistant_chat <span class="ot">&lt;-</span> <span class="fu">chat_google_gemini</span>(</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">"gemini-2.0-flash"</span>,</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">system_prompt =</span> <span class="st">"You are the 'Official Lab Assistant'. Your job is to answer questions by exclusively using the information provided from the lab's SOP documents. If the answer is not in the provided documents, you must state that the information is not available in the lab protocols. Do not use your general knowledge."</span>,</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">api_key =</span> <span class="fu">Sys.getenv</span>(<span class="st">"GEMINI_API_KEY"</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co"># This is the magic step! Register the retrieval function as a tool.</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>lab_chat <span class="ot">&lt;-</span> <span class="fu">ragnar_register_tool_retrieve</span>(lab_assistant_chat, store)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Ask the Lab Assistant questions!</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, when you ask a question, the LLM will first use the `ragnar_retrieve` tool to search the documents, then use the retrieved text to formulate its answer.</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Question 1 (Answer is in SOP-03)</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>lab_chat<span class="sc">$</span><span class="fu">chat</span>(<span class="st">"What is a good 260/280 ratio for my RNA samples?"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>◯ [tool call] rag_retrieve_from_store_001(text = "acceptable 260/280 ratio for
RNA samples")</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>● #&gt; [{"origin":"./lab_sops/SOP-01_Cell-Culture.md","doc_id":1,"chunk_id":1,"s…</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>A 260/280 ratio of approximately 2.0 is generally accepted as pure for RNA. 
Ratios significantly lower may indicate protein contamination.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Question 2 (Answer is in SOP-02)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>lab_chat<span class="sc">$</span><span class="fu">chat</span>(<span class="st">"How long should I block my western blot membrane, and what should I use for blocking?"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>◯ [tool call] rag_retrieve_from_store_001(text = "western blot membrane
blocking protocol")</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>■ #&gt; Error: ℹ In argument: `origin = first(origin)`.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>  #&gt; Caused by error in `x[[1L]]`:</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>  #&gt; ! subscript out of bounds</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>According to SOP-002: Western Blot Membrane Blocking, you should block the 
membrane for 1 hour at room temperature on an orbital shaker. The blocking 
buffer should be prepared by dissolving 5g of non-fat dry milk in 100mL of TBST
(5% w/v). Do not use BSA as the blocking agent for phospho-specific antibodies.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Question 3 (Answer is NOT in the SOPs)</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>lab_chat<span class="sc">$</span><span class="fu">chat</span>(<span class="st">"What is the protocol for performing a comet assay?"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>◯ [tool call] rag_retrieve_from_store_001(text = "Comet assay protocol")</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>■ #&gt; Error: ℹ In argument: `origin = first(origin)`.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>  #&gt; Caused by error in `x[[1L]]`:</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>  #&gt; ! subscript out of bounds</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>The information about the comet assay protocol is not available in the lab 
protocols.</code></pre>
</div>
</div>
</section>
</section>
<section id="module-2-conclusion" class="level2">
<h2 class="anchored" data-anchor-id="module-2-conclusion">Module 2 Conclusion</h2>
<p>Fantastic work! You have now built a complete, end-to-end RAG system.You can: * Create a knowledge store from your own documents (<code>ragnar_store_create</code>). * Ingest and chunk text documents into the store (<code>ragnar_store_insert</code>). * Give an <code>ellmer</code> chatbot the ability to search your private knowledge store. * Build a specialised chatbot that answers questions based only on your data.</p>
<p>This workflow is incredibly powerful for creating reliable, accurate, and helpful AI assistants for any domain-specific knowledge you have. In the final module, we’ll look at <code>chattr</code>, which provides a polished user interface for these kinds of interactions directly inside RStudio.</p>
</section>
</section>
<section id="module-3-chattr---llm-integration-in-r-studio" class="level1">
<h1><strong>Module 3: <code>chattr</code> - LLM Integration in R Studio</strong></h1>
<p><a href="https://mlverse.github.io/chattr/"><code>chattr</code></a> provides a user-friendly interface for interacting with LLMs directly within the RStudio IDE. It offers a Shiny-based chat application and RStudio add-ins to streamline your workflow and make it easy to incorporate LLM-generated code and text into your projects.</p>
<p><strong>Key Concepts:</strong> * <strong>Shiny Gadget:</strong> Learn how to use the <code>chattr</code> Shiny gadget for interactive conversations with LLMs. * <strong>RStudio Add-ins:</strong> Discover how to use <code>chattr</code>’s RStudio add-ins to send prompts and insert LLM-generated code directly into your scripts. * <strong>Contextual Awareness:</strong> Understand how <code>chattr</code> can automatically include information about your current R environment (e.g., loaded data frames, open files) in your prompts.</p>
<section id="chattr-in-rstudio" class="level3">
<h3 class="anchored" data-anchor-id="chattr-in-rstudio">Chattr in RStudio</h3>
<p>Load packages and set api key.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ellmer, <span class="at">lib.loc =</span> <span class="st">"./Rlibs"</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(chattr, <span class="at">lib.loc =</span> <span class="st">"./Rlibs"</span>)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Set your Gemini API key value</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Sys.setenv(GEMINI_API_KEY = "xxxx")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>chat <span class="ot">&lt;-</span> ellmer<span class="sc">::</span><span class="fu">chat_google_gemini</span>(</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">"gemini-2.5-flash"</span>, </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">api_key=</span><span class="fu">Sys.getenv</span>(<span class="st">"GEMINI_API_KEY"</span>)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="fu">chattr_use</span>(chat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>── chattr </code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>• Provider: Google/Gemini</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>• Model: gemini-2.5-flash</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>• Label: gemini-2.5-flash (Google/Gemini)</code></pre>
</div>
</div>
<p>Now call the app!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># chattr_app()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># chattr("Make me a ggplot example")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="conclusion-and-further-resources" class="level1">
<h1><strong>Conclusion and Further Resources</strong></h1>
<p>This workshop has provided you with a solid foundation for using LLMs in R. You’ve learned how to: * Interact with various LLMs using <code>ellmer</code>. * Build powerful RAG workflows with <code>ragnar</code>. * Seamlessly integrate LLMs into your RStudio workflow with <code>chattr</code>.</p>
<p>Now you’re ready to explore the endless possibilities of using LLMs to enhance your R-based research.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>